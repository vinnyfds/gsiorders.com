---
description: 
globs: 
alwaysApply: true
---
# üéØ **CRITICAL RULE: NO SHORTCUTS OR SIMPLIFIED VERSIONS**


---

## **üö´ ANTI-SHORTCUT ENFORCEMENT RULES**

### **NEVER COMPROMISE ON SPECIFICATIONS**

```typescript
/**
 * CURSOR AI ABSOLUTE RULE: 
 * NEVER create simplified/dumbed-down versions just to "pass tests" or "get something working"
 */

const noShortcutRules = {
  // FORBIDDEN BEHAVIORS:
  forbidden: [
    '‚ùå Creating "basic version" when full version is specified',
    '‚ùå Removing features to make implementation easier', 
    '‚ùå Using placeholder/mock data instead of real integration',
    '‚ùå Skipping error handling because "it works without it"',
    '‚ùå Omitting responsive design because "desktop works"',
    '‚ùå Hardcoding values instead of dynamic implementation',
    '‚ùå Creating fake success responses to pass tests',
    '‚ùå Removing TypeScript types to avoid complexity'
  ],

  // REQUIRED BEHAVIORS:
  required: [
    '‚úÖ Implement FULL functionality as specified',
    '‚úÖ Meet ALL success criteria before marking complete',
    '‚úÖ Handle ALL edge cases and error scenarios', 
    '‚úÖ Include ALL responsive breakpoints',
    '‚úÖ Implement ALL accessibility requirements',
    '‚úÖ Use REAL data integration, not mocks',
    '‚úÖ Add COMPLETE TypeScript type coverage',
    '‚úÖ Follow ALL project patterns and standards'
  ]
};
```

### **Specification Adherence Validation**

```typescript
const specificationAdherenceRules = {
  // BEFORE marking ANY task complete, validate:
  
  fullFunctionalityCheck: {
    // Example: CartModal.tsx requirements
    specified: [
      'Shows cart items with product details',
      'Quantity controls (+ and - buttons)', 
      'Remove item functionality',
      'Cart total calculation',
      'Checkout button integration',
      'Empty cart state handling',
      'Loading states for all operations',
      'Error handling for failed operations',
      'Mobile responsive design',
      'Accessibility compliance'
    ],
    
    // FORBIDDEN shortcuts:
    notAcceptable: [
      '‚ùå "Simple list without quantity controls"',
      '‚ùå "Static total without real calculation"', 
      '‚ùå "Checkout button that just console.logs"',
      '‚ùå "No error handling - will add later"',
      '‚ùå "Works on desktop only for now"',
      '‚ùå "Mock data instead of real cart integration"'
    ],

    validation: `
      // CURSOR AI MUST verify EVERY requirement:
      const validateCartModal = {
        ‚úÖ cartItemsDisplay: 'Shows real cart data from useCart hook',
        ‚úÖ quantityControls: 'Working + and - buttons that update cart',
        ‚úÖ removeItem: 'Remove button that calls removeFromCart API',
        ‚úÖ totalCalculation: 'Real-time total based on actual prices',
        ‚úÖ checkoutIntegration: 'Button creates actual Stripe session',
        ‚úÖ emptyState: 'Shows proper empty cart message and CTA',
        ‚úÖ loadingStates: 'All buttons disable during API calls',
        ‚úÖ errorHandling: 'Shows user-friendly error messages',
        ‚úÖ mobileResponsive: 'Works perfectly on 375px screen',
        ‚úÖ accessibility: 'Screen reader compatible with ARIA labels'
      };
      
      // IF ANY ‚úÖ is false, task is NOT COMPLETE
    `
  }
};
```

---

## **üí™ FULL IMPLEMENTATION ENFORCEMENT**

### **Quality Over Speed Rules**

```typescript
const qualityOverSpeedRules = {
  // WRONG MINDSET vs RIGHT MINDSET:
  
  wrongApproach: {
    thinking: 'This is complex, let me make a simple version first',
    actions: [
      'Creating basic UI without real functionality',
      'Hardcoding responses instead of API integration',
      'Skipping edge cases and error handling',
      'Making it work only for happy path',
      'Planning to "improve it later"'
    ],
    result: 'INCOMPLETE, LOW-QUALITY IMPLEMENTATION'
  },

  rightApproach: {
    thinking: 'This is complex, let me break it into proper steps and implement fully',
    actions: [
      'Analyze requirements thoroughly',
      'Plan implementation with all edge cases',
      'Implement step-by-step but completely',
      'Test each piece thoroughly',
      'Ensure integration works end-to-end'
    ],
    result: 'COMPLETE, PRODUCTION-READY IMPLEMENTATION'
  },

  timeManagement: `
    // CURSOR AI RULE: If task is taking longer than estimated:
    // ‚ùå DON'T: Reduce scope or create simplified version
    // ‚úÖ DO: Document the complexity, ask for help, or extend timeline
    // ‚úÖ DO: Break into smaller sub-tasks if needed
    // ‚úÖ DO: Implement fully even if it takes extra time
  `
};
```

### **No Mock/Placeholder Rules**

```typescript
const noMockDataRules = {
  // CURSOR AI MUST use real implementations:
  
  realIntegration: {
    // ‚ùå FORBIDDEN: Mock/fake implementations
    forbidden: [
      'const mockCartItems = [{ id: "1", name: "Test Product" }]',
      'const checkout = () => console.log("Would redirect to Stripe")',
      'const addToCart = () => alert("Added to cart!")',
      'if (loading) return <div>Loading...</div> // fake loading'
    ],

    // ‚úÖ REQUIRED: Real implementations  
    required: [
      'const { cart, addToCart, isLoading } = useCart(); // real hook',
      'const handleCheckout = () => fetch("/api/checkout", { ... }); // real API',
      'const handleAddToCart = async (id) => await addToCart(id); // real function',
      'if (isLoading) return <LoadingSkeleton />; // real loading UI'
    ]
  },

  realDataFlow: {
    // End-to-end real functionality required:
    example: `
      // CART MODAL REAL IMPLEMENTATION REQUIRED:
      
      ‚úÖ Real cart data from Supabase
      ‚úÖ Real quantity updates via API calls  
      ‚úÖ Real total calculation from actual prices
      ‚úÖ Real checkout button that creates Stripe session
      ‚úÖ Real error handling for failed API calls
      ‚úÖ Real loading states during operations
      ‚úÖ Real empty state when cart is empty
      
      // NOT ACCEPTABLE:
      ‚ùå Hardcoded cart items
      ‚ùå Fake quantity controls that don't persist
      ‚ùå Static total that doesn't update
      ‚ùå Checkout button that just logs to console
      ‚ùå No error handling
      ‚ùå Fake loading states
    `
  }
};
```

---

## **üéØ SUCCESS CRITERIA ENFORCEMENT**

### **Binary Success Validation**

```typescript
const binarySuccessRules = {
  // Task completion is BINARY: Either 100% complete or NOT complete
  
  completionStandards: {
    // NO partial credit, NO "good enough", NO "works mostly"
    rule: 'SUCCESS CRITERIA MUST BE 100% MET',
    
    examples: {
      // CartModal.tsx success criteria:
      cartModal: {
        required: [
          'Displays cart items with product images, names, prices',
          'Quantity controls update cart via API and persist',
          'Remove buttons delete items via API',
          'Total calculates correctly and updates in real-time',
          'Checkout button creates real Stripe session',
          'Empty state shows when cart is empty',
          'Loading states during all async operations',
          'Error messages for failed operations',
          'Mobile responsive design (375px+)',
          'Keyboard navigation works',
          'Screen reader accessible'
        ],
        
        validation: `
          // EVERY item must be ‚úÖ before task is complete:
          const allRequirementsMet = required.every(req => 
            implementationMeets(req) === true
          );
          
          if (!allRequirementsMet) {
            taskStatus = 'INCOMPLETE - Continue working';
            // DO NOT mark as done or create simplified version
          }
        `
      }
    }
  },

  // NO EXCUSES allowed for incomplete implementation:
  noExcusesPolicy: [
    '‚ùå "It mostly works" - NOT ACCEPTABLE',
    '‚ùå "Good enough for now" - NOT ACCEPTABLE', 
    '‚ùå "Can improve later" - NOT ACCEPTABLE',
    '‚ùå "Basic version is ready" - NOT ACCEPTABLE',
    '‚ùå "Complex parts can wait" - NOT ACCEPTABLE',
    '‚ùå "Tests are passing" (with shortcuts) - NOT ACCEPTABLE'
  ]
};
```

### **Implementation Depth Requirements**

```typescript
const implementationDepthRules = {
  // CURSOR AI must implement to production-ready depth:
  
  productionReadyStandards: {
    // EVERY feature must include:
    required: [
      '‚úÖ Full functionality as specified',
      '‚úÖ Comprehensive error handling',
      '‚úÖ Loading states for all async operations',
      '‚úÖ Input validation and sanitization',
      '‚úÖ Responsive design for all devices',
      '‚úÖ Accessibility compliance (WCAG AA)',
      '‚úÖ TypeScript type safety',
      '‚úÖ Integration with existing systems',
      '‚úÖ Performance optimization',
      '‚úÖ Security considerations'
    ],

    // NOT ACCEPTABLE to skip:
    notAcceptable: [
      '‚ùå "Basic functionality without error handling"',
      '‚ùå "Works but not responsive"',
      '‚ùå "No loading states - will add later"', 
      '‚ùå "Hard-coded values for now"',
      '‚ùå "Not accessible yet"',
      '‚ùå "Any TypeScript - will type later"',
      '‚ùå "Doesn\'t integrate with existing code"'
    ]
  },

  exampleStandard: `
    // EXAMPLE: ProductCard component requirements
    
    // ‚ùå NOT ACCEPTABLE (simplified version):
    const ProductCard = ({ product }) => (
      <div>
        <img src={product.image} />
        <h3>{product.name}</h3>
        <p>${product.price}</p>
        <button onClick={() => alert('Added!')}>Add to Cart</button>
      </div>
    );
    
    // ‚úÖ REQUIRED (full implementation):
    const ProductCard: React.FC<ProductCardProps> = ({ 
      product, 
      onAddToCart, 
      className,
      ...rest 
    }) => {
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);
      
      const handleAddToCart = async () => {
        try {
          setIsLoading(true);
          setError(null);
          await onAddToCart(product.id);
        } catch (err) {
          setError('Failed to add to cart. Please try again.');
        } finally {
          setIsLoading(false);
        }
      };
      
      return (
        <article 
          className={cn('product-card', className)}
          data-testid="product-card"
          {...rest}
        >
          <img 
            src={product.image || '/placeholder.jpg'}
            alt={product.name}
            className="product-image"
            loading="lazy"
          />
          <h3 className="heading-3">{product.name}</h3>
          <p className="text-brand-primary font-semibold">
            ${product.price.toFixed(2)}
          </p>
          {error && (
            <p className="text-error text-sm" role="alert">
              {error}
            </p>
          )}
          <button
            onClick={handleAddToCart}
            disabled={isLoading || product.inventory_count === 0}
            className="btn-primary w-full"
            aria-label={`Add ${product.name} to cart`}
          >
            {isLoading ? 'Adding...' : 'Add to Cart'}
          </button>
        </article>
      );
    };
  `
};
```

---

## **‚ö° COMPLEXITY HANDLING RULES**

### **When Implementation Gets Difficult**

```typescript
const complexityHandlingRules = {
  // WHEN task becomes more complex than expected:
  
  properResponse: [
    '‚úÖ ANALYZE: Break down into smaller logical steps',
    '‚úÖ RESEARCH: Look for existing patterns in codebase',
    '‚úÖ PLAN: Document approach before coding',
    '‚úÖ IMPLEMENT: Build piece by piece, test each piece',
    '‚úÖ INTEGRATE: Ensure it works with existing systems',
    '‚úÖ VERIFY: Test all edge cases and error scenarios'
  ],

  wrongResponse: [
    '‚ùå Reduce functionality to make it easier',
    '‚ùå Skip error handling to get basic version working',
    '‚ùå Use placeholder/mock data instead of real integration',
    '‚ùå Make it work only for happy path',
    '‚ùå Skip responsive design because it\'s complex',
    '‚ùå Remove TypeScript types because they\'re hard'
  ],

  escalationProcess: `
    // IF task is genuinely too complex for single implementation:
    
    1. ‚úÖ DOCUMENT the complexity and specific challenges
    2. ‚úÖ BREAK DOWN into logical sub-tasks
    3. ‚úÖ IMPLEMENT each sub-task completely
    4. ‚úÖ INTEGRATE sub-tasks into working whole
    5. ‚úÖ TEST the complete implementation
    
    // NEVER:
    ‚ùå Create incomplete version and call it done
    ‚ùå Skip requirements to make it simpler
    ‚ùå Plan to "finish it later"
  `
};
```

### **Quality Gate Enforcement**

```typescript
const qualityGateRules = {
  // MANDATORY quality gates before task completion:
  
  mustPass: [
    'üéØ ALL requirements implemented',
    'üîç ALL edge cases handled',
    '‚ö° ALL loading states working',
    'üö® ALL error scenarios covered',
    'üì± ALL responsive breakpoints working',
    '‚ôø ALL accessibility requirements met',
    'üîó ALL integrations working end-to-end',
    'üß™ ALL tests passing (including manual testing)',
    'üìñ ALL documentation updated',
    '‚ú® ALL code follows project patterns'
  ],

  // IF ANY gate fails:
  failureResponse: 'CONTINUE WORKING - Task is NOT complete',
  
  // NO EXCEPTIONS for:
  noExceptions: [
    'Time pressure',
    'Complexity',
    'Testing difficulties', 
    '"Good enough" mentality',
    'Desire to move to next task',
    'Frustration with implementation'
  ]
};
```

---

**‚úÖ CURSOR AI ANTI-SHORTCUT RULES SUMMARY:**

- [x] **NEVER create simplified versions** just to pass tests
- [x] **ALWAYS implement full functionality** as specified  
- [x] **NO mock/placeholder implementations** - real integration only
- [x] **100% success criteria required** before marking complete
- [x] **Production-ready depth mandatory** for all features
- [x] **Quality over speed enforcement** 
- [x] **Proper complexity handling** without compromising requirements
- [x] **Binary completion standards** - either 100% done or not done

**üéØ Cursor AI will now maintain full specification adherence and NEVER compromise on quality to get "something working"!**


